{"version":3,"sources":["js/main.js"],"names":["LambdaError","response","this","name","message","errorMessage","stack","stackTrace","isUrl","url","pattern","RegExp","test","isArray","array","Array","constructor","isEmpty","value","isFunction","fn","getClass","toString","call","addEventListener","element","event","handler","removeEventListener","attachEvent","callback","detachEvent","hasClass","className","classList","contains","addClass","_typeof","add","removeClass","remove","replace","split","join","toggleClass","toggle","classes","existingIndex","indexOf","splice","push","getParameterByName","regex","results","exec","decodeURIComponent","getElementsById","ids","document","Error","getElementById","map","id","_defineProperty","reduce","acc","Object","assign","getParameters","list","href","val","obj","prototype","create","checkError","parseJSON","json","fetchLambda","options","fetch","then","Promise","reject"],"mappings":"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","file":"js/main.js","sourcesContent":["/**\n * Returns true if url has a url format\n * TODO\n * Has some issues\n * @param  {Any} url url to test\n * @return {Bolean}     has url a url format\n */\nconst isUrl = (url) => {\n\tconst pattern = new RegExp('^(https?:\\\\/\\\\/)?'+ // protocol\n  '((([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*)\\\\.?)+[a-z]{2,}|'+ // domain name\n  '((\\\\d{1,3}\\\\.){3}\\\\d{1,3}))'+ // OR ip (v4) address\n  '(\\\\:\\\\d+)?(\\\\/[-a-z\\\\d%_.~+]*)*'+ // port and path\n  '(\\\\?[;&a-z\\\\d%_.~+=-]*)?'+ // query string\n  '(\\\\#[-a-z\\\\d_]*)?$','i')\n\treturn !!url && pattern.test(url)\n}\n/**\n * Returns true if array is an Array.\n * @param  {Any} array test argument.\n * @return {Boolean}   test result.\n */\nconst isArray = (array) => !!(array && Array === array.constructor)\n/**\n * Returns true if the value is an empty string.\n * @param  {Any} value Value to test.\n * @return {Boolean}   Test result.\n */\nconst isEmpty = (value) => value === ''\n/**\n * Returns true if fn is a Function\n * @param  {Any} fn  test argument\n * @return {Boolean} test result\n */\nconst isFunction = (fn) => {\n\tconst getClass = {}\n\treturn !!fn && getClass.toString.call(fn) === '[object Function]';\n}\n/**\n * Adds an event listener to a document element and\n * returns a function to disable the event listener.\n * @param  {Element}  element Document element.\n * @param  {String}   event   Event name.\n * @param  {Function} handler Event handler function.\n * @return {Function}         Unsubscribe event handler.\n */\nconst addEventListener = (element, event, handler) => {\n\tif (!!element.addEventListener) {\n\t\tif (event === 'onsubmit') event = 'submit'\n\t\telement.addEventListener(event, handler, false)\n\t\treturn () => element.removeEventListener(event, handler)\n\t} else {\n\t\telement.attachEvent(event, callback)\n\t\treturn () => element.detachEvent(event, handler)\n\t}\n}\n/**\n * Checks if the provided element has a given class.\n * @param  {Element} element   DOM element.\n * @param  {String} className  Class name\n * @return {Boolean}           True if element has that class.\n */\nconst hasClass = (element, className) => {\n\tif (element.classList)\n\t  element.classList.contains(className);\n\telse\n  \tnew RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);\n}\n/**\n * Adds a class to a given element.\n * @param  {Element} element   Document element.\n * @param  {String}  className className to apply\n * @return {Void}\n */\nconst addClass = (element, className) => {\n\tif (!element)\n\t\treturn\n\telse if (typeof element.classList === 'object') \n\t\telement.classList.add(className)\n\telse\n\t\telement.className += ' ' + className\n}\n/**\n * Removes a class from an element.\n * @param  {Element} element   Document element.\n * @param  {String}  className className to remove.\n * @return {Void}\n */\nconst removeClass = (element, className) => {\n\tif (!element)\n\t\treturn\n\telse if (element.classList)\n\t\telement.classList.remove(className)\n\telse\n\t\telement.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ')\n}\n/**\n * Toggles a class from an element.\n * @param  {Element} element   Document element.\n * @param  {String}  className Class name\n * @return {Void}\n */\nconst toggleClass = (element, className) => {\n\tif (element.classList) {\n\t  element.classList.toggle(className);\n\t} else {\n\t  var classes = element.className.split(' ');\n\t  var existingIndex = classes.indexOf(className);\n\t  if (existingIndex >= 0)\n\t    classes.splice(existingIndex, 1);\n\t  else\n\t    classes.push(className);\n\t  element.className = classes.join(' ');\n\t}\n}\n/**\n * Returns the value of a query parameter from a url\n * @param  {String} name Query parameter name.\n * @param  {String} url  URL string\n * @return {String}      Query parameter value.\n */\nconst getParameterByName = (name, url) => {\n\tif (!url) return;\n  name = name.replace(/[\\[\\]]/g, '\\\\$&');\n  var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),\n      results = regex.exec(url);\n  if (!results) return null;\n  if (!results[2]) return '';\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '));\n}\n/**\n * Takes a list of ids and returns an object with the\n * ids as keys and the elements associated to it as\n * values.\n * @param  {Array}    ids      List of ids.\n * @param  {Document} document Document element\n * @return {Object}            Element object\n */\nconst getElementsById = (ids, document) => {\n\tif (!document || !ids) throw new Error('undefined arguments')\n\tif (!isFunction(document.getElementById)) throw new Error('document.getElementById is not a function')\n\tif (!isArray(ids)) throw new Error('ids is not an array')\n\treturn ids\n\t\t.map(id => ({[id]: document.getElementById(id)}))\n\t\t.reduce((acc, id) => Object.assign(acc, id), {})\n}\n/**\n * Takes an array of parameters and returns an object\n * with the names of the parameters as keys and the \n * query values as the keys values.\n * @param  {Array}  ids      Array of keys\n * @param  {String} document URL string\n * @return {Object}          Parameters objects\n */\nconst getParameters = (list, href) => {\n\tif (!list || !href) throw new Error('undefined arguments')\n\tif (!isArray(list)) throw new Error('list is not an array')\n\treturn list\n\t\t.map(val => ({[val]: getParameterByName(val, href)}))\n\t\t.reduce((acc, obj) => Object.assign(acc, obj), {})\n}\n/**\t\n *  This is taken from the Mozilla Documentation\n */\n/**\n * [LambdaError description]\n * @param {Object} response Lambda response object.\n */\nfunction LambdaError(response) {\n\tthis.name = 'LambdaError'\n\tthis.message = response.errorMessage\n\tthis.stack = response.stackTrace\n}\n/**\n * Set LambdaError prototype to the Error.prototype\n * @type {Error}\n */\nLambdaError.prototype = Object.create(Error.prototype)\n/**\n * Set the constructor to LambdaError\n * @type {LambdaError}\n */\nLambdaError.prototype.constructor = LambdaError\n/**\n * Checks the lambda response object for an error\n * message.\n * @param  {Object} response    Lambda response\n * @return {Object|LambdaError} The response object or an Error\n */\nconst checkError = (response) => {\n\tif (!!response.errorMessage) \n\t\tthrow new LambdaError(response)\n\telse\n\t\treturn response\n}\n/**\n * Takes fetch response and grabs the body of the response.\n * @param  {Object} response Fetch json response body.\n * @return {Object}          JSON response body.\n */\nconst parseJSON = (response) => response.json()\n/**\n * Wrapper function around fetch to simplify calls to\n * Lambda functions through API Gateway\n * @param  {String} url     URL.\n * @param  {Object} options Fetch options.\n * @return {Promise}        The fetch promise or an error wrapped in a promise.\n */\nconst fetchLambda = (url, options) => {\n\tif (!fetch) return new Promise.reject(new Error('fetch is undefined'))\n\treturn fetch(url, options)\n\t\t.then(parseJSON)\n\t\t.then(checkError)\n}\n"],"sourceRoot":"/source/"}