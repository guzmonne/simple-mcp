{"version":3,"sources":["js/main.js"],"names":["LambdaError","response","this","name","message","errorMessage","stack","stackTrace","map","array","fn","result","length","isFunction","i","push","isUrl","url","pattern","RegExp","test","isArray","Array","constructor","isEmpty","value","getClass","toString","call","decamelize","string","separator","TypeError","replace","toLowerCase","urlParams","params","Object","keys","reduce","key","decamelKey","hasOwnProperty","concat","join","urlBuilder","addEventListener","element","event","handler","removeEventListener","attachEvent","callback","detachEvent","hasClass","className","classList","contains","addClass","_typeof","add","removeClass","remove","split","toggleClass","toggle","classes","existingIndex","indexOf","splice","getParameterByName","regex","results","exec","decodeURIComponent","getElementsById","ids","document","Error","getElementById","id","_defineProperty","acc","assign","getParameters","list","href","val","obj","prototype","create","checkError","parseJSON","json","fetchLambda","options","fetch","then","Promise","reject","fetchJSONLambda","body","method","headers","Accept","Content-Type","JSON","stringify"],"mappings":"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","file":"js/main.js","sourcesContent":[" \nconst map = (array, fn) => {\n\tconst result = []\n\tif (!array || !array.length) return result\n\tif (!isFunction(fn)) return result\n\tfor (let i = 0; i < array.length; i++){\n\t\tresult.push(fn(array[i], i, array))\n\t}\n\treturn result\n}\n/**\n * Returns true if url has a url format\n * TODO\n * Has some issues\n * @param  {Any} url url to test\n * @return {Bolean}     has url a url format\n */\nconst isUrl = (url) => {\n\tconst pattern = new RegExp('^(https?:\\\\/\\\\/)?'+ // protocol\n  '((([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*)\\\\.?)+[a-z]{2,}|'+ // domain name\n  '((\\\\d{1,3}\\\\.){3}\\\\d{1,3}))'+ // OR ip (v4) address\n  '(\\\\:\\\\d+)?(\\\\/[-a-z\\\\d%_.~+]*)*'+ // port and path\n  '(\\\\?[;&a-z\\\\d%_.~+=-]*)?'+ // query string\n  '(\\\\#[-a-z\\\\d_]*)?$','i')\n\treturn !!url && pattern.test(url)\n}\n/**\n * Returns true if array is an Array.\n * @param  {Any} array test argument.\n * @return {Boolean}   test result.\n */\nconst isArray = (array) => !!(array && Array === array.constructor)\n/**\n * Returns true if the value is an empty string.\n * @param  {Any} value Value to test.\n * @return {Boolean}   Test result.\n */\nconst isEmpty = (value) => value === ''\n/**\n * Returns true if fn is a Function\n * @param  {Any} fn  test argument\n * @return {Boolean} test result\n */\nconst isFunction = (fn) => {\n\tconst getClass = {}\n\treturn !!fn && getClass.toString.call(fn) === '[object Function]';\n}\n/**\n * Convert a camelized string into a lowercased one with a custom separator\n * Example: unicornRainbow â†’ unicorn_rainbow\n * @param  {String} string    String to convert.\n * @param  {String} separator Separator.\n * @return {String}           Decamelized string.\n */\nconst decamelize = (string, separator) => {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\tseparator = typeof separator === 'undefined' ? '_' : separator;\n\treturn string\n\t\t.replace(/([a-z\\d])([A-Z])/g, '$1' + separator + '$2')\n\t\t.replace(/([A-Z]+)([A-Z][a-z\\d]+)/g, '$1' + separator + '$2')\n\t\t.toLowerCase();\n};\n/**\n * Creates &amp; separated params string\n * @param params {object}\n */\nconst urlParams = (params) => Object.keys(params)\n\t.reduce((result, key) => {\n\t\tconst decamelKey = decamelize(key)\n\t\tconst value      = params[key]\n\t\treturn params.hasOwnProperty(key) ? \n\t\t\tresult.concat(`${decamelKey}=${value}`) : result\n\t}, [])\n\t.join('&')\n/**\n * Creates url with params\n * @param url {string} url base\n * @param params {object} url params\n */\nconst urlBuilder = (url, params) => `${url}?${urlParams(params)}`\n/**\n * Adds an event listener to a document element and\n * returns a function to disable the event listener.\n * @param  {Element}  element Document element.\n * @param  {String}   event   Event name.\n * @param  {Function} handler Event handler function.\n * @return {Function}         Unsubscribe event handler.\n */\nconst addEventListener = (element, event, handler) => {\n\tif (!!element.addEventListener) {\n\t\tif (event === 'onsubmit') event = 'submit'\n\t\telement.addEventListener(event, handler, false)\n\t\treturn () => element.removeEventListener(event, handler)\n\t} else {\n\t\telement.attachEvent(event, callback)\n\t\treturn () => element.detachEvent(event, handler)\n\t}\n}\n/**\n * Checks if the provided element has a given class.\n * @param  {Element} element   DOM element.\n * @param  {String} className  Class name\n * @return {Boolean}           True if element has that class.\n */\nconst hasClass = (element, className) => {\n\tif (element.classList)\n\t  element.classList.contains(className);\n\telse\n  \tnew RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);\n}\n/**\n * Adds a class to a given element.\n * @param  {Element} element   Document element.\n * @param  {String}  className className to apply\n * @return {Void}\n */\nconst addClass = (element, className) => {\n\tif (!element)\n\t\treturn\n\telse if (typeof element.classList === 'object') \n\t\telement.classList.add(className)\n\telse\n\t\telement.className += ' ' + className\n}\n/**\n * Removes a class from an element.\n * @param  {Element} element   Document element.\n * @param  {String}  className className to remove.\n * @return {Void}\n */\nconst removeClass = (element, className) => {\n\tif (!element)\n\t\treturn\n\telse if (element.classList)\n\t\telement.classList.remove(className)\n\telse\n\t\telement.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ')\n}\n/**\n * Toggles a class from an element.\n * @param  {Element} element   Document element.\n * @param  {String}  className Class name\n * @return {Void}\n */\nconst toggleClass = (element, className) => {\n\tif (element.classList) {\n\t  element.classList.toggle(className);\n\t} else {\n\t  var classes = element.className.split(' ');\n\t  var existingIndex = classes.indexOf(className);\n\t  if (existingIndex >= 0)\n\t    classes.splice(existingIndex, 1);\n\t  else\n\t    classes.push(className);\n\t  element.className = classes.join(' ');\n\t}\n}\n/**\n * Returns the value of a query parameter from a url\n * @param  {String} name Query parameter name.\n * @param  {String} url  URL string\n * @return {String}      Query parameter value.\n */\nconst getParameterByName = (name, url) => {\n\tif (!url) return;\n  name = name.replace(/[\\[\\]]/g, '\\\\$&');\n  var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),\n      results = regex.exec(url);\n  if (!results) return null;\n  if (!results[2]) return '';\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '));\n}\n/**\n * Takes a list of ids and returns an object with the\n * ids as keys and the elements associated to it as\n * values.\n * @param  {Array}    ids      List of ids.\n * @param  {Document} document Document element\n * @return {Object}            Element object\n */\nconst getElementsById = (ids, document) => {\n\tif (!document || !ids) throw new Error('undefined arguments')\n\tif (!isFunction(document.getElementById)) throw new Error('document.getElementById is not a function')\n\tif (!isArray(ids)) throw new Error('ids is not an array')\n\treturn ids\n\t\t.map(id => ({[id]: document.getElementById(id)}))\n\t\t.reduce((acc, id) => Object.assign(acc, id), {})\n}\n/**\n * Takes an array of parameters and returns an object\n * with the names of the parameters as keys and the \n * query values as the keys values.\n * @param  {Array}  ids      Array of keys\n * @param  {String} document URL string\n * @return {Object}          Parameters objects\n */\nconst getParameters = (list, href) => {\n\tif (!list || !href) throw new Error('undefined arguments')\n\tif (!isArray(list)) throw new Error('list is not an array')\n\treturn list\n\t\t.map(val => ({[val]: getParameterByName(val, href)}))\n\t\t.reduce((acc, obj) => Object.assign(acc, obj), {})\n}\n/**\t\n *  This is taken from the Mozilla Documentation\n */\n/**\n * [LambdaError description]\n * @param {Object} response Lambda response object.\n */\nfunction LambdaError(response) {\n\tthis.name = 'LambdaError'\n\tthis.message = response.errorMessage\n\tthis.stack = response.stackTrace\n}\n/**\n * Set LambdaError prototype to the Error.prototype\n * @type {Error}\n */\nLambdaError.prototype = Object.create(Error.prototype)\n/**\n * Set the constructor to LambdaError\n * @type {LambdaError}\n */\nLambdaError.prototype.constructor = LambdaError\n/**\n * Checks the lambda response object for an error\n * message.\n * @param  {Object} response    Lambda response\n * @return {Object|LambdaError} The response object or an Error\n */\nconst checkError = (response) => {\n\tif (!!response.errorMessage) \n\t\tthrow new LambdaError(response)\n\telse\n\t\treturn response\n}\n/**\n * Takes fetch response and grabs the body of the response.\n * @param  {Object} response Fetch json response body.\n * @return {Object}          JSON response body.\n */\nconst parseJSON = (response) => response.json()\n/**\n * Wrapper function around fetch to simplify calls to\n * Lambda functions through API Gateway\n * @param  {String} url     URL.\n * @param  {Object} options Fetch options.\n * @return {Promise}        The fetch promise.\n */\nconst fetchLambda = (url, options) => {\n\tif (!fetch) return new Promise.reject(new Error('fetch is undefined'))\n\treturn fetch(url, options)\n\t\t.then(parseJSON)\n\t\t.then(checkError)\n}\n/**\n * Wrapper function around fetchLambda to simplify calls\n * to Lambda functions asking for JSON objects providing \n * some information inside the body..\n * @param  {String} url            Lambda function URL.\n * @param  {Any}    body           Fetch JSON body.\n * @param  {String} options.method One of POST, GET, PUT, DESTROY\n * @return {Promise}               The fetch promise.\n */\nconst fetchJSONLambda = (url, body, options) => \n\tfetchLambda(url, {\n\t\tmethod: !!options && !!options.method ? options.method : 'POST',\n\t\theaders: {\n\t    'Accept': 'application/json',\n\t    'Content-Type': 'application/json'\n\t  },\n\t\tbody: JSON.stringify(body),\n\t})"],"sourceRoot":"/source/"}