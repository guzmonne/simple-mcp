{"version":3,"sources":["js/main.js"],"names":["LambdaError","response","this","name","message","errorMessage","stack","stackTrace","isUrl","url","pattern","RegExp","test","isArray","array","Array","constructor","isFunction","fn","getClass","toString","call","addEventListener","element","event","handler","removeEventListener","attachEvent","callback","detachEvent","addClass","className","_typeof","classList","add","removeClass","remove","replace","split","join","toggleClass","toggle","classes","existingIndex","indexOf","splice","push","getParameterByName","regex","results","exec","decodeURIComponent","getElementsById","ids","document","Error","getElementById","map","id","_defineProperty","reduce","acc","Object","assign","getParameters","list","href","val","obj","prototype","create","checkError","parseJSON","json"],"mappings":"mJAqJA,QAASA,aAAYC,GACpBC,KAAKC,KAAO,cACZD,KAAKE,QAAUH,EAASI,aAFzBH,KAAAI,MAASL,EAAYM,2MA9IfC,MAAQ,SAACC,GACd,GAAMC,GAAU,GAAIC,QAAO,yKADtB,IACL,SAAMF,GAAUC,EAAIE,KAAOH,IAD5BI,QAAA,SAAAC,GAAA,SAAAA,GAAAC,QAAAD,EAAAE,cAcMC,WAAU,SAAAC,GAAA,GAAAC,KAAhB,SAAAD,GAAA,sBAAAC,EAAAC,SAAAC,KAAAH,IAUAI,iBAAA,SAAAC,EAAAC,EAAAC,GASC,MAAMF,GAAQD,kBACC,aAAVE,IAAsBA,EAAQ,UAClCD,EAAQD,iBAAiBE,EAAOC,GAAS,GAClC,WAAA,MAAMF,GAAQG,oBAAoBF,EAAOC,MAEhDF,EAAQI,YAAYH,EAAOI,UACpB,WAAA,MAAML,GAAQM,YAAYL,EAAOC,MADxCK,SAAQ,SAAAP,EAAYQ,GACpBR,IAAA,WAAAS,QAAAT,EAAAU,WACAV,EAAAU,UAAAC,IAAAH,GAEFR,EAAAQ,WAAA,IAAAA,IAMAI,YAAA,SAAAZ,EAAAQ,GAQAR,IASUA,EAAQU,UAChBV,EAAQU,UAAUG,OAAOL,GAEzBR,EAAQQ,UAAYR,EAAQQ,UAAUM,QAAQ,GAAI1B,QAAO,UAAYoB,EAAUO,MAAM,KAAKC,KAAK,KAAO,UAAW,MAAO,OAQpHC,YAAc,SAACjB,EAASQ,GAC7B,GAAIR,EAAQU,UADbV,EAAMU,UAAcQ,OAAdV,OACD,CACF,GAAAW,GAAQnB,EAAUQ,UAAOO,MAAzB,KADFK,EAEOD,EAAAE,QAAAb,EACLY,IAAc,EACdD,EAAIG,OAAAF,EAAwB,GAK5BD,EAAQI,KAAAf,GACTR,EAAAQ,UAAAW,EAAAH,KAAA,OASGQ,mBAAM,SAAA5C,EAAAM,GACT,GAAAA,EAAA,CACAN,EAAIA,EAAQkC,QAAI,UAAO,OAAvB,IACIW,GAAA,GAAUrC,QAAM,OADpBR,EAAA,qBAEI8C,EAAUD,EAAAE,KAAAzC,EACd,OAAKwC,GACLA,EAAO,GAPTE,mBAAAF,EAAA,GAAAZ,QAAA,MAAA,MAOS,GADU,OAYde,gBAAJ,SAAuBC,EAAAC,GACvB,IAAIA,IAAYD,EAAA,KAAS,IAAAE,OAAA,sBACzB,KAAItC,WAASqC,EAAME,gBAAgB,KAAA,IAAAD,OAAhB,4CACnB,KAAA1C,QACEwC,GAAI,KAAA,IAAAE,OAAA,sBAAA,OAAAF,GADCI,IAEL,SAAAC,GAAA,MAAAC,oBAAOD,EAAAJ,EAAAE,eAAAE,MAAAE,OAAA,SAAaC,EAAAH,GAAb,MAAoBI,QAAYC,OAAhCF,EAAAH,SAUJM,cAAgB,SAACC,EAAMC,GAA7B,IAAMD,IAAAC,EAAgB,KAAA,IAAhBX,OAAA,sBACL,KAAI1C,QAAAoD,GAAJ,KAAoB,IAAMV,OAAA,uBAC1B,OAAKU,GACLR,IAAA,SAAAU,GAAA,MAAAR,oBAAOQ,EACDpB,mBAAAoB,EAAAD,MAAAN,OAAA,SAAAC,EAAAO,GAAA,MAAAN,QAAUC,OAAMF,EAAAO,QAmBvBpE,aAAYqE,UAAYP,OAAOQ,OAAOf,MAAMc,WAK5CrE,YAAYqE,UAAUrD,YAAchB,WAOpC,IAAMuE,YAAa,SAACtE,GACnB,GAAMA,EAASI,aACd,KAAM,IAAIL,aAAYC,EADvB,OAAMA,IAUDuE,UAAY,SAAAvE,GAAA,MAAZA,GAAawE","file":"js/main.js","sourcesContent":["/**\n * Returns true if url has a url format\n * TODO\n * Has some issues\n * @param  {Any} url url to test\n * @return {Bolean}     has url a url format\n */\nconst isUrl = (url) => {\n\tconst pattern = new RegExp('^(https?:\\\\/\\\\/)?'+ // protocol\n  '((([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*)\\\\.?)+[a-z]{2,}|'+ // domain name\n  '((\\\\d{1,3}\\\\.){3}\\\\d{1,3}))'+ // OR ip (v4) address\n  '(\\\\:\\\\d+)?(\\\\/[-a-z\\\\d%_.~+]*)*'+ // port and path\n  '(\\\\?[;&a-z\\\\d%_.~+=-]*)?'+ // query string\n  '(\\\\#[-a-z\\\\d_]*)?$','i')\n\treturn !!url && pattern.test(url)\n}\n/**\n * Returns true if array is an Array\n * @param  {Any} array test argument\n * @return {Boolean}   test result\n */\nconst isArray = (array) => !!(array && Array === array.constructor)\n/**\n * Returns true if fn is a Function\n * @param  {Any} fn  test argument\n * @return {Boolean} test result\n */\nconst isFunction = (fn) => {\n\tconst getClass = {}\n\treturn !!fn && getClass.toString.call(fn) === '[object Function]';\n}\n/**\n * Adds an event listener to a document element and\n * returns a function to disable the event listener.\n * @param  {Element}  element Document element.\n * @param  {String}   event   Event name.\n * @param  {Function} handler Event handler function.\n * @return {Function}         Unsubscribe event handler.\n */\nconst addEventListener = (element, event, handler) => {\n\tif (!!element.addEventListener) {\n\t\tif (event === 'onsubmit') event = 'submit'\n\t\telement.addEventListener(event, handler, false)\n\t\treturn () => element.removeEventListener(event, handler)\n\t} else {\n\t\telement.attachEvent(event, callback)\n\t\treturn () => element.detachEvent(event, handler)\n\t}\n}\n/**\n * Adds a class to a given element.\n * @param  {Element} element   Document element.\n * @param  {String}  className className to apply\n * @return {Void}\n */\nconst addClass = (element, className) => {\n\tif (!element)\n\t\treturn\n\telse if (typeof element.classList === 'object') \n\t\telement.classList.add(className)\n\telse\n\t\telement.className += ' ' + className\n}\n/**\n * Removes a class from an element.\n * @param  {Element} element   Document element.\n * @param  {String}  className className to remove.\n * @return {Void}\n */\nconst removeClass = (element, className) => {\n\tif (!element)\n\t\treturn\n\telse if (element.classList)\n\t\telement.classList.remove(className)\n\telse\n\t\telement.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ')\n}\n/**\n * Toggles a class from an element.\n * @param  {Element} element   Document element.\n * @param  {String}  className Class name\n * @return {Void}\n */\nconst toggleClass = (element, className) => {\n\tif (element.classList) {\n\t  element.classList.toggle(className);\n\t} else {\n\t  var classes = element.className.split(' ');\n\t  var existingIndex = classes.indexOf(className);\n\t  if (existingIndex >= 0)\n\t    classes.splice(existingIndex, 1);\n\t  else\n\t    classes.push(className);\n\t  element.className = classes.join(' ');\n\t}\n}\n/**\n * Returns the value of a query parameter from a url\n * @param  {String} name Query parameter name.\n * @param  {String} url  URL string\n * @return {String}      Query parameter value.\n */\nconst getParameterByName = (name, url) => {\n\tif (!url) return;\n  name = name.replace(/[\\[\\]]/g, '\\\\$&');\n  var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),\n      results = regex.exec(url);\n  if (!results) return null;\n  if (!results[2]) return '';\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '));\n}\n/**\n * Takes a list of ids and returns an object with the\n * ids as keys and the elements associated to it as\n * values.\n * @param  {Array}    ids      List of ids.\n * @param  {Document} document Document element\n * @return {Object}            Element object\n */\nconst getElementsById = (ids, document) => {\n\tif (!document || !ids) throw new Error('undefined arguments')\n\tif (!isFunction(document.getElementById)) throw new Error('document.getElementById is not a function')\n\tif (!isArray(ids)) throw new Error('ids is not an array')\n\treturn ids\n\t\t.map(id => ({[id]: document.getElementById(id)}))\n\t\t.reduce((acc, id) => Object.assign(acc, id), {})\n}\n/**\n * Takes an array of parameters and returns an object\n * with the names of the parameters as keys and the \n * query values as the keys values.\n * @param  {Array}  ids      Array of keys\n * @param  {String} document URL string\n * @return {Object}          Parameters objects\n */\nconst getParameters = (list, href) => {\n\tif (!list || !href) throw new Error('undefined arguments')\n\tif (!isArray(list)) throw new Error('list is not an array')\n\treturn list\n\t\t.map(val => ({[val]: getParameterByName(val, href)}))\n\t\t.reduce((acc, obj) => Object.assign(acc, obj), {})\n}\n/**\t\n *  This is taken from the Mozilla Documentation\n */\n/**\n * [LambdaError description]\n * @param {Object} response Lambda response object.\n */\nfunction LambdaError(response) {\n\tthis.name = 'LambdaError'\n\tthis.message = response.errorMessage\n\tthis.stack = response.stackTrace\n}\n/**\n * Set LambdaError prototype to the Error.prototype\n * @type {Error}\n */\nLambdaError.prototype = Object.create(Error.prototype)\n/**\n * Set the constructor to LambdaError\n * @type {LambdaError}\n */\nLambdaError.prototype.constructor = LambdaError\n/**\n * Checks the lambda response object for an error\n * message.\n * @param  {Object} response    Lambda response\n * @return {Object|LambdaError} The response object or an Error\n */\nconst checkError = (response) => {\n\tif (!!response.errorMessage) \n\t\tthrow new LambdaError(response)\n\telse\n\t\treturn response\n}\n/**\n * Takes fetch response and grabs the body of the response.\n * @param  {Object} response Fetch json response body.\n * @return {Object}          JSON response body.\n */\nconst parseJSON = (response) => response.json()\n"],"sourceRoot":"/source/"}