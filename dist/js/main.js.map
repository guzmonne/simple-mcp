{"version":3,"sources":["js/main.js"],"names":["LambdaError","response","this","name","message","errorMessage","stack","stackTrace","map","array","fn","result","length","isFunction","i","push","isUrl","url","pattern","RegExp","test","isArray","Array","constructor","isEmpty","value","getClass","toString","call","addEventListener","element","event","handler","removeEventListener","attachEvent","callback","detachEvent","hasClass","className","classList","contains","addClass","_typeof","add","removeClass","remove","replace","split","join","toggleClass","toggle","classes","existingIndex","indexOf","splice","getParameterByName","regex","results","exec","decodeURIComponent","getElementsById","ids","document","Error","getElementById","id","_defineProperty","reduce","acc","Object","assign","getParameters","list","href","val","obj","prototype","create","checkError","parseJSON","json","fetchLambda","options","fetch","then","Promise","reject"],"mappings":"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","file":"js/main.js","sourcesContent":[" \nconst map = (array, fn) => {\n\tconst result = []\n\tif (!array || !array.length) return result\n\tif (!isFunction(fn)) return result\n\tfor (let i = 0; i < array.length; i++){\n\t\tresult.push(fn(array[i], i, array))\n\t}\n\treturn result\n}\n/**\n * Returns true if url has a url format\n * TODO\n * Has some issues\n * @param  {Any} url url to test\n * @return {Bolean}     has url a url format\n */\nconst isUrl = (url) => {\n\tconst pattern = new RegExp('^(https?:\\\\/\\\\/)?'+ // protocol\n  '((([a-z\\\\d]([a-z\\\\d-]*[a-z\\\\d])*)\\\\.?)+[a-z]{2,}|'+ // domain name\n  '((\\\\d{1,3}\\\\.){3}\\\\d{1,3}))'+ // OR ip (v4) address\n  '(\\\\:\\\\d+)?(\\\\/[-a-z\\\\d%_.~+]*)*'+ // port and path\n  '(\\\\?[;&a-z\\\\d%_.~+=-]*)?'+ // query string\n  '(\\\\#[-a-z\\\\d_]*)?$','i')\n\treturn !!url && pattern.test(url)\n}\n/**\n * Returns true if array is an Array.\n * @param  {Any} array test argument.\n * @return {Boolean}   test result.\n */\nconst isArray = (array) => !!(array && Array === array.constructor)\n/**\n * Returns true if the value is an empty string.\n * @param  {Any} value Value to test.\n * @return {Boolean}   Test result.\n */\nconst isEmpty = (value) => value === ''\n/**\n * Returns true if fn is a Function\n * @param  {Any} fn  test argument\n * @return {Boolean} test result\n */\nconst isFunction = (fn) => {\n\tconst getClass = {}\n\treturn !!fn && getClass.toString.call(fn) === '[object Function]';\n}\n/**\n * Adds an event listener to a document element and\n * returns a function to disable the event listener.\n * @param  {Element}  element Document element.\n * @param  {String}   event   Event name.\n * @param  {Function} handler Event handler function.\n * @return {Function}         Unsubscribe event handler.\n */\nconst addEventListener = (element, event, handler) => {\n\tif (!!element.addEventListener) {\n\t\tif (event === 'onsubmit') event = 'submit'\n\t\telement.addEventListener(event, handler, false)\n\t\treturn () => element.removeEventListener(event, handler)\n\t} else {\n\t\telement.attachEvent(event, callback)\n\t\treturn () => element.detachEvent(event, handler)\n\t}\n}\n/**\n * Checks if the provided element has a given class.\n * @param  {Element} element   DOM element.\n * @param  {String} className  Class name\n * @return {Boolean}           True if element has that class.\n */\nconst hasClass = (element, className) => {\n\tif (element.classList)\n\t  element.classList.contains(className);\n\telse\n  \tnew RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);\n}\n/**\n * Adds a class to a given element.\n * @param  {Element} element   Document element.\n * @param  {String}  className className to apply\n * @return {Void}\n */\nconst addClass = (element, className) => {\n\tif (!element)\n\t\treturn\n\telse if (typeof element.classList === 'object') \n\t\telement.classList.add(className)\n\telse\n\t\telement.className += ' ' + className\n}\n/**\n * Removes a class from an element.\n * @param  {Element} element   Document element.\n * @param  {String}  className className to remove.\n * @return {Void}\n */\nconst removeClass = (element, className) => {\n\tif (!element)\n\t\treturn\n\telse if (element.classList)\n\t\telement.classList.remove(className)\n\telse\n\t\telement.className = element.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ')\n}\n/**\n * Toggles a class from an element.\n * @param  {Element} element   Document element.\n * @param  {String}  className Class name\n * @return {Void}\n */\nconst toggleClass = (element, className) => {\n\tif (element.classList) {\n\t  element.classList.toggle(className);\n\t} else {\n\t  var classes = element.className.split(' ');\n\t  var existingIndex = classes.indexOf(className);\n\t  if (existingIndex >= 0)\n\t    classes.splice(existingIndex, 1);\n\t  else\n\t    classes.push(className);\n\t  element.className = classes.join(' ');\n\t}\n}\n/**\n * Returns the value of a query parameter from a url\n * @param  {String} name Query parameter name.\n * @param  {String} url  URL string\n * @return {String}      Query parameter value.\n */\nconst getParameterByName = (name, url) => {\n\tif (!url) return;\n  name = name.replace(/[\\[\\]]/g, '\\\\$&');\n  var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),\n      results = regex.exec(url);\n  if (!results) return null;\n  if (!results[2]) return '';\n  return decodeURIComponent(results[2].replace(/\\+/g, ' '));\n}\n/**\n * Takes a list of ids and returns an object with the\n * ids as keys and the elements associated to it as\n * values.\n * @param  {Array}    ids      List of ids.\n * @param  {Document} document Document element\n * @return {Object}            Element object\n */\nconst getElementsById = (ids, document) => {\n\tif (!document || !ids) throw new Error('undefined arguments')\n\tif (!isFunction(document.getElementById)) throw new Error('document.getElementById is not a function')\n\tif (!isArray(ids)) throw new Error('ids is not an array')\n\treturn ids\n\t\t.map(id => ({[id]: document.getElementById(id)}))\n\t\t.reduce((acc, id) => Object.assign(acc, id), {})\n}\n/**\n * Takes an array of parameters and returns an object\n * with the names of the parameters as keys and the \n * query values as the keys values.\n * @param  {Array}  ids      Array of keys\n * @param  {String} document URL string\n * @return {Object}          Parameters objects\n */\nconst getParameters = (list, href) => {\n\tif (!list || !href) throw new Error('undefined arguments')\n\tif (!isArray(list)) throw new Error('list is not an array')\n\treturn list\n\t\t.map(val => ({[val]: getParameterByName(val, href)}))\n\t\t.reduce((acc, obj) => Object.assign(acc, obj), {})\n}\n/**\t\n *  This is taken from the Mozilla Documentation\n */\n/**\n * [LambdaError description]\n * @param {Object} response Lambda response object.\n */\nfunction LambdaError(response) {\n\tthis.name = 'LambdaError'\n\tthis.message = response.errorMessage\n\tthis.stack = response.stackTrace\n}\n/**\n * Set LambdaError prototype to the Error.prototype\n * @type {Error}\n */\nLambdaError.prototype = Object.create(Error.prototype)\n/**\n * Set the constructor to LambdaError\n * @type {LambdaError}\n */\nLambdaError.prototype.constructor = LambdaError\n/**\n * Checks the lambda response object for an error\n * message.\n * @param  {Object} response    Lambda response\n * @return {Object|LambdaError} The response object or an Error\n */\nconst checkError = (response) => {\n\tif (!!response.errorMessage) \n\t\tthrow new LambdaError(response)\n\telse\n\t\treturn response\n}\n/**\n * Takes fetch response and grabs the body of the response.\n * @param  {Object} response Fetch json response body.\n * @return {Object}          JSON response body.\n */\nconst parseJSON = (response) => response.json()\n/**\n * Wrapper function around fetch to simplify calls to\n * Lambda functions through API Gateway\n * @param  {String} url     URL.\n * @param  {Object} options Fetch options.\n * @return {Promise}        The fetch promise or an error wrapped in a promise.\n */\nconst fetchLambda = (url, options) => {\n\tif (!fetch) return new Promise.reject(new Error('fetch is undefined'))\n\treturn fetch(url, options)\n\t\t.then(parseJSON)\n\t\t.then(checkError)\n}\n"],"sourceRoot":"/source/"}